  !> Read the UNK generated by QE for Wannier and the wannier90
  !> checkpoint file. The part that reads the checkpoint file has been
  !> adapted from wannier90,
  !> Copyright (C) 2007-13 Jonathan Yates, Arash Mostofi,       
  !>                Giovanni Pizzi, Young-Su Lee,               
  !>                Nicola Marzari, Ivo Souza, David Vanderbilt 
  !> Distributed under GNU/GPL v2.
  module subroutine read_unk(f,file,filedn,omega,nou,dochk)
    use tools_math, only: det, matinv
    use tools_io, only: fopen_read, getline_raw, lgetword, equal, ferror, faterr, &
       fclose, string, fopen_write, uout
    use types, only: realloc
    use param, only: bohrtoa
    class(grid3), intent(inout) :: f
    character*(*), intent(in) :: file !< Input file (spin up or total)
    character*(*), intent(in) :: filedn !< Input file (spin down)
    real*8, intent(in) :: omega
    logical, intent(in) :: nou
    logical, intent(in) :: dochk

    integer :: luc, luw
    integer :: nspin, ispin, ibnd, nbnd, jbnd, idum, nall(3)
    integer :: n(3), ik, ik1, ik2, ik3, naux(3), ikk
    real*8 :: fspin
    integer :: i, j, k, l
    complex*16, allocatable :: raux(:,:,:), raux2(:,:,:)
    integer :: nk1, nk2, nk3, nk
    character(len=:), allocatable :: fname, oname, sijfname
    logical :: haschk
    ! for the wannier checkpoint (wannier90, 2.0.1)
    character(len=33) :: header
    real*8 :: rlatt(3,3), rclatt(3,3), rlatti(3,3)
    character(len=20) :: chkpt1
    logical :: have_disentangled
    complex*16, allocatable :: u_matrix(:,:,:)
    complex*16 :: cdum

    call f%end()

    ! spin
    if (len_trim(filedn) < 1) then
       nspin = 1
       fspin = 2d0
    else
       nspin = 2
       fspin = 1d0
    end if

    ! checkpoint files
    haschk = .false.
    if (dochk) then
       sijfname = trim(file) // "-sij"
       inquire(file=sijfname,exist=haschk)
    end if

    ! read the grid size from the unk or the checkpoint
    if (haschk) then
       luc = fopen_read(sijfname,form="unformatted")
       read (luc) n
       call fclose(luc)
    else
       luc = fopen_read("UNK00001.1",form="unformatted")
       read(luc) n, idum, jbnd
       call fclose(luc)
    endif
    f%n = n

    ! allocate the density
    if (allocated(f%f)) deallocate(f%f)
    allocate(f%f(f%n(1),f%n(2),f%n(3)))
    f%f = 0d0

    ! read the chk file/s
    do ispin = 1, nspin
       if (ispin == 1) then
          luc = fopen_read(file,form="unformatted")
       else
          luc = fopen_read(filedn,form="unformatted")
       end if

       ! header and number of bands
       read(luc) header
       read(luc) nbnd 
       read(luc) jbnd 
       if (jbnd > 0) &
          call ferror("read_unk","number of excluded bands /= 0",faterr)
       read(luc) (idum,i=1,jbnd) 

       ! real and reciprocal lattice
       read(luc) ((rlatt(i,j),i=1,3),j=1,3)
       if (abs(det(rlatt) / bohrtoa**3 - omega) / omega > 1d-2) & 
          call ferror("read_unk","wannier and current structure's volumes differ by more than 1%",faterr)
       read(luc) ((rclatt(i,j),i=1,3),j=1,3)
    
       ! number of k-points
       read(luc) nk 
       read(luc) nk1, nk2, nk3
       if (nk == 0 .or. nk1 == 0 .or. nk2 == 0 .or. nk3 == 0 .or. nk /= (nk1*nk2*nk3)) &
          call ferror("read_unk","no monkhorst-pack grid or inconsistent k-point number",faterr)

       ! k-points
       allocate(f%wan%kpt(3,nk))
       read(luc) ((f%wan%kpt(i,j),i=1,3),j=1,nk) 
       do i = 1, nk
          ik1 = nint(f%wan%kpt(1,i) * nk1)
          ik2 = nint(f%wan%kpt(2,i) * nk2)
          ik3 = nint(f%wan%kpt(3,i) * nk3)
          if (abs(f%wan%kpt(1,i) * nk1 - ik1) > 1d-5 .or.abs(f%wan%kpt(2,i) * nk2 - ik2) > 1d-5 .or.&
             abs(f%wan%kpt(3,i) * nk3 - ik3) > 1d-5) then
             write (uout,*) f%wan%kpt(:,i)
             write (uout,*) f%wan%kpt(1,i)*nk1,f%wan%kpt(1,i)*nk2,f%wan%kpt(1,i)*nk3
             write (uout,*) ik1, ik2, ik3
             call ferror("read_unk","not a (uniform) monkhorst-pack grid or shifted grid",faterr)
          end if
       end do

       read(luc) idum ! number of nearest k-point neighbours
       read(luc) jbnd ! number of wannier functions
       if (jbnd /= nbnd) &
          call ferror("read_unk","number of wannier functions /= number of bands",faterr)
       
       ! checkpoint positon and disentanglement
       read(luc) chkpt1
       read(luc) have_disentangled
       if (have_disentangled) & 
          call ferror("read_unk","can not handle disentangled wannier functions",faterr)

       ! u and m matrices
       if (allocated(u_matrix)) deallocate(u_matrix)
       allocate(u_matrix(nbnd,nbnd,nk))
       read(luc) (((u_matrix(i,j,k),i=1,nbnd),j=1,nbnd),k=1,nk)
       read(luc) ((((cdum,i=1,nbnd),j=1,nbnd),k=1,idum),l=1,nk) ! m matrix

       ! wannier centers and spreads
       if (ispin == 1) then
          if (allocated(f%wan%center)) deallocate(f%wan%center)
          if (allocated(f%wan%spread)) deallocate(f%wan%spread)
          allocate(f%wan%center(3,nbnd,nspin),f%wan%spread(nbnd,nspin))
       else
          if (nbnd > size(f%wan%spread,1)) then
             call realloc(f%wan%center,3,nbnd,nspin)
             call realloc(f%wan%spread,nbnd,nspin)
          end if
       end if
       read(luc) ((f%wan%center(i,j,ispin),i=1,3),j=1,nbnd)
       read(luc) (f%wan%spread(i,ispin),i=1,nbnd)

       ! end of wannier checkpoint
       call fclose(luc)

       ! dimensions for the supercell
       f%wan%nwan = (/nk1,nk2,nk3/)
       f%wan%nks = nk1*nk2*nk3
       nall = f%n * f%wan%nwan

       ! convert centers to crystallographic and spread to bohr
       rlatti = matinv(rlatt)
       do i = 1, nbnd
          f%wan%center(:,i,ispin) = matmul(f%wan%center(:,i,ispin),rlatti)
          do j = 1, 3
             if (f%wan%center(j,i,ispin) > f%wan%nwan(j)) &
                f%wan%center(j,i,ispin) = f%wan%center(j,i,ispin) - f%wan%nwan(j)
             if (f%wan%center(j,i,ispin) < 0d0) &
                f%wan%center(j,i,ispin) = f%wan%center(j,i,ispin) + f%wan%nwan(j)
          end do
          f%wan%spread(i,ispin) = sqrt(f%wan%spread(i,ispin)) / bohrtoa
       end do

       if (.not.haschk) then
          ! allocate arrays and fill some info
          if (.not.nou) allocate(raux(n(1),n(2),n(3)))
          allocate(raux2(n(1),n(2),n(3)))

          do ik = 1, nk
             ! unk file name
             fname = "UNK" // string(ik,5,pad0=.true.) // "." // string(ispin)

             ! open file for reading
             luc = fopen_read(fname,form="unformatted")

             ! read the header
             read(luc) naux, ikk, idum

             ! read the bands and pass them to the WNK file open file for writing
             do ibnd = 1, nbnd
                oname = "WNK." // string(ik) // "." // string(ibnd) // "." // string(ispin)
                luw = fopen_write(oname,form="unformatted")

                if (.not.nou) then
                   ! apply the transformation
                   raux2 = 0d0
                   rewind(luc)
                   read(luc) naux, ikk, idum
                   do jbnd = 1, nbnd
                      read(luc) raux
                      raux2 = raux2 + u_matrix(jbnd,ibnd,ik) * raux
                   end do
                else
                   ! transfer this band to the new file
                   read(luc) raux2
                end if

                ! write and close
                write(luw) raux2
                call fclose(luw)

                f%f = f%f + real(conjg(raux2) * raux2,8)
             end do

             ! close the unk file
             call fclose(luc)
          end do
          if (allocated(raux)) deallocate(raux)
          deallocate(raux2)
       end if
    end do

    if (haschk) then
       ! read the density from the checkpoint file
       luc = fopen_read(sijfname,form="unformatted")
       read (luc) n
       read (luc) f%f
       call fclose(luc)
    else
       f%f = f%f * fspin / omega / real(nk,8)
    end if

    f%wan%hasuevc = .false.
    f%wan%useunkgen = .false.
    f%wan%sijchk = dochk
    f%wan%haschk = haschk
    f%isinit = .true.
    f%mode = mode_default
    f%iswan = .true.
    f%wan%nbnd = nbnd
    f%wan%nspin = nspin
    if (allocated(f%wan%ngk)) deallocate(f%wan%ngk)
    if (allocated(f%wan%igk_k)) deallocate(f%wan%igk_k)
    if (allocated(f%wan%nls)) deallocate(f%wan%nls)
    if (allocated(f%wan%u)) deallocate(f%wan%u)

  end subroutine read_unk

