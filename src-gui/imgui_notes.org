* dock
struct DockContext
	enum Slot_
	enum EndAction_
	enum Status_
	struct Dock
		Dock()
		~Dock() { MemFree(label); }
		ImVec2 getMinSize() const
		bool isHorizontal() const
		void setParent(Dock* dock)
		Dock& getSibling()
		Dock& getFirstTab()
		void setActive()
		bool isContainer() const
		void setChildrenPosSize(const ImVec2& _pos, const ImVec2& _size)
		void setPosSize(const ImVec2& _pos, const ImVec2& _size)

		ImU32 id;
		char* label;
		Dock* next_tab;
		Dock* prev_tab;
		Dock* parent;
		ImVec2 pos;
		ImVec2 size;
		bool active;
		Status_ status;
		bool opened;

		Dock* children[2];
		char location[16];
		int last_frame;
		int invalid_frames;
		bool first;

	ImVector<Dock*> m_docks;
	ImVec2 m_drag_offset;
	Dock* m_current = nullptr;
	int m_last_frame = 0;
	EndAction_ m_end_action;

	~DockContext() {}

	Dock& getDock(const char* label, bool opened)
	void putInBackground()
	void splits()
	void checkNonexistent()
	void beginPanel()
	void endPanel()
	Dock* getDockAt(const ImVec2& /*pos*/) const
	static ImRect getDockedRect(const ImRect& rect, Slot_ dock_slot)
	static ImRect getSlotRect(ImRect parent_rect, Slot_ dock_slot)
	static ImRect getSlotRectOnBorder(ImRect parent_rect, Slot_ dock_slot)
	Dock* getRootDock()
	bool dockSlots(Dock& dock, Dock* dest_dock, const ImRect& rect, bool on_border)
	void handleDrag(Dock& dock)
	void fillLocation(Dock& dock)
	void doUndock(Dock& dock)
	void drawTabbarListButton(Dock& dock)
	bool tabbar(Dock& dock, bool close_button)
	static void setDockPosSize(Dock& dest, Dock& dock, Slot_ dock_slot, Dock& container)
	void doDock(Dock& dock, Dock* dest, Slot_ dock_slot)
	void rootDock(const ImVec2& pos, const ImVec2& size)
	void setDockActive()
	static Slot_ getSlotFromLocationCode(char code)
	static char getLocationCode(Dock* dock)
	void tryDockToStoredLocation(Dock& dock)
	bool begin(const char* label, bool* opened, ImGuiWindowFlags extra_flags)
	void end()
	int getDockIndex(Dock* dock)
	void save()
	Dock* getDockByIndex(int idx) { return idx < 0 ? nullptr : m_docks[(int)idx]; }
	void load()

static DockContext g_dock;
void Print() 
void ShutdownDock()
void RootDock(const ImVec2& pos, const ImVec2& size)
void SetDockActive()
bool BeginDock(const char* label, bool* opened, ImGuiWindowFlags extra_flags)
void EndDock()
void SaveDock()
void LoadDock()


* Helper functions
bool ImIsPointInTriangle(const ImVec2& p, const ImVec2& a, const ImVec2& b, const ImVec2& c)
int ImStricmp(const char* str1, const char* str2)
int ImStrnicmp(const char* str1, const char* str2, int count)
void ImStrncpy(char* dst, const char* src, int count)
char* ImStrdup(const char *str)
int ImStrlenW(const ImWchar* str)
const ImWchar* ImStrbolW(const ImWchar* buf_mid_line, const ImWchar* buf_begin) // find beginning-of-line
const char* ImStristr(const char* haystack, const char* haystack_end, const char* needle, const char* needle_end)
int ImFormatString(char* buf, int buf_size, const char* fmt, ...)
int ImFormatStringV(char* buf, int buf_size, const char* fmt, va_list args)
ImU32 ImHash(const void* data, int data_size, ImU32 seed)

* ImText* helpers
int ImTextCharFromUtf8(unsigned int* out_char, const char* in_text, const char* in_text_end)
int ImTextStrFromUtf8(ImWchar* buf, int buf_size, const char* in_text, const char* in_text_end, const char** in_text_remaining)
int ImTextCountCharsFromUtf8(const char* in_text, const char* in_text_end)
int ImTextStrToUtf8(char* buf, int buf_size, const ImWchar* in_text, const ImWchar* in_text_end)
int ImTextCountUtf8BytesFromStr(const ImWchar* in_text, const ImWchar* in_text_end)

* Color helpers
ImVec4 ImGui::ColorConvertU32ToFloat4(ImU32 in)
ImU32 ImGui::ColorConvertFloat4ToU32(const ImVec4& in)
ImU32 ImGui::GetColorU32(ImGuiCol idx, float alpha_mul)  
ImU32 ImGui::GetColorU32(const ImVec4& col)
void ImGui::ColorConvertRGBtoHSV(float r, float g, float b, float& out_h, float& out_s, float& out_v)
void ImGui::ColorConvertHSVtoRGB(float h, float s, float v, float& out_r, float& out_g, float& out_b)

* File helpers
FILE* ImFileOpen(const char* filename, const char* mode)
void* ImFileLoadToMemory(const char* filename, const char* file_open_mode, int* out_file_size, int padding_bytes)

* ImGuiStorage
struct ImGuiStorage
{
    struct Pair
    {
        ImGuiID key;
        union { int val_i; float val_f; void* val_p; };
        Pair(ImGuiID _key, int _val_i) { key = _key; val_i = _val_i; }
        Pair(ImGuiID _key, float _val_f) { key = _key; val_f = _val_f; }
        Pair(ImGuiID _key, void* _val_p) { key = _key; val_p = _val_p; }
    };
    ImVector<Pair>      Data;

    // - Get***() functions find pair, never add/allocate. Pairs are sorted so a query is O(log N)
    // - Set***() functions find pair, insertion on demand if missing.
    // - Sorted insertion is costly, paid once. A typical frame shouldn't need to insert any new pair.
    IMGUI_API void      Clear();
    IMGUI_API int       GetInt(ImGuiID key, int default_val = 0) const;
    IMGUI_API void      SetInt(ImGuiID key, int val);
    IMGUI_API bool      GetBool(ImGuiID key, bool default_val = false) const;
    IMGUI_API void      SetBool(ImGuiID key, bool val);
    IMGUI_API float     GetFloat(ImGuiID key, float default_val = 0.0f) const;
    IMGUI_API void      SetFloat(ImGuiID key, float val);
    IMGUI_API void*     GetVoidPtr(ImGuiID key) const; // default_val is NULL
    IMGUI_API void      SetVoidPtr(ImGuiID key, void* val);

    // - Get***Ref() functions finds pair, insert on demand if missing, return pointer. Useful if you intend to do Get+Set.
    // - References are only valid until a new value is added to the storage. Calling a Set***() function or a Get***Ref() function invalidates the pointer.
    // - A typical use case where this is convenient for quick hacking (e.g. add storage during a live Edit&Continue session if you can't modify existing struct)
    //      float* pvar = ImGui::GetFloatRef(key); ImGui::SliderFloat("var", pvar, 0, 100.0f); some_var += *pvar;
    IMGUI_API int*      GetIntRef(ImGuiID key, int default_val = 0);
    IMGUI_API bool*     GetBoolRef(ImGuiID key, bool default_val = false);
    IMGUI_API float*    GetFloatRef(ImGuiID key, float default_val = 0.0f);
    IMGUI_API void**    GetVoidPtrRef(ImGuiID key, void* default_val = NULL);

    // Use on your own storage if you know only integer are being stored (open/close all tree nodes)
    IMGUI_API void      SetAllInt(int val);
};

* ImGuiTextFilter
struct ImGuiTextFilter
{
    struct TextRange
    {
        const char* b;
        const char* e;

        TextRange() { b = e = NULL; }
        TextRange(const char* _b, const char* _e) { b = _b; e = _e; }
        const char* begin() const { return b; }
        const char* end() const { return e; }
        bool empty() const { return b == e; }
        char front() const { return *b; }
        static bool is_blank(char c) { return c == ' ' || c == '\t'; }
        void trim_blanks() { while (b < e && is_blank(*b)) b++; while (e > b && is_blank(*(e-1))) e--; }
        IMGUI_API void split(char separator, ImVector<TextRange>& out);
    };

    char                InputBuf[256];
    ImVector<TextRange> Filters;
    int                 CountGrep;

    ImGuiTextFilter(const char* default_filter = "");
    ~ImGuiTextFilter() {}
    void                Clear() { InputBuf[0] = 0; Build(); }
    bool                Draw(const char* label = "Filter (inc,-exc)", float width = 0.0f);    // Helper calling InputText+Build
    bool                PassFilter(const char* text, const char* text_end = NULL) const;
    bool                IsActive() const { return !Filters.empty(); }
    IMGUI_API void      Build();
};

* ImGuiTextBuffer
struct ImGuiTextBuffer
{
    ImVector<char>      Buf;

    ImGuiTextBuffer()   { Buf.push_back(0); }
    inline char         operator[](int i) { return Buf.Data[i]; }
    const char*         begin() const { return &Buf.front(); }
    const char*         end() const { return &Buf.back(); }      // Buf is zero-terminated, so end() will point on the zero-terminator
    int                 size() const { return Buf.Size - 1; }
    bool                empty() { return Buf.Size <= 1; }
    void                clear() { Buf.clear(); Buf.push_back(0); }
    const char*         c_str() const { return Buf.Data; }
    IMGUI_API void      append(const char* fmt, ...) IM_PRINTFARGS(2);
    IMGUI_API void      appendv(const char* fmt, va_list args);
};

* ImGuiSimpleColumns
struct ImGuiSimpleColumns
{
    int         Count;
    float       Spacing;
    float       Width, NextWidth;
    float       Pos[8], NextWidths[8];

    ImGuiSimpleColumns();
    void        Update(int count, float spacing, bool clear);
    float       DeclColumns(float w0, float w1, float w2);
    float       CalcExtraSpace(float avail_w);
};

* ImGuiListClipper
struct ImGuiListClipper
{
    float   StartPosY;
    float   ItemsHeight;
    int     ItemsCount, StepNo, DisplayStart, DisplayEnd;

    // items_count:  Use -1 to ignore (you can call Begin later). Use INT_MAX if you don't know how many items you have (in which case the cursor won't be advanced in the final step).
    // items_height: Use -1.0f to be calculated automatically on first step. Otherwise pass in the distance between your items, typically GetTextLineHeightWithSpacing() or GetItemsLineHeightWithSpacing().
    // If you don't specify an items_height, you NEED to call Step(). If you specify items_height you may call the old Begin()/End() api directly, but prefer calling Step().
    ImGuiListClipper(int items_count = -1, float items_height = -1.0f)  { Begin(items_count, items_height); } // NB: Begin() initialize every fields (as we allow user to call Begin/End multiple times on a same instance if they want).
    ~ImGuiListClipper()                                                 { IM_ASSERT(ItemsCount == -1); }      // Assert if user forgot to call End() or Step() until false.

    IMGUI_API bool Step();                                              // Call until it returns false. The DisplayStart/DisplayEnd fields will be set and you can process/draw those items.
    IMGUI_API void Begin(int items_count, float items_height = -1.0f);  // Automatically called by constructor if you passed 'items_count' or by Step() in Step 1.
    IMGUI_API void End();                                               // Automatically called on the last call of Step() that returns false.
};

* ImGuiWindow
struct ImGuiWindow
{
    char*                   Name;
    ImGuiID                 ID;                                 // == ImHash(Name)
    ImGuiWindowFlags        Flags;                              // See enum ImGuiWindowFlags_
    int                     OrderWithinParent;                  // Order within immediate parent window, if we are a child window. Otherwise 0.
    ImVec2                  PosFloat;
    ImVec2                  Pos;                                // Position rounded-up to nearest pixel
    ImVec2                  Size;                               // Current size (==SizeFull or collapsed title bar size)
    ImVec2                  SizeFull;                           // Size when non collapsed
    ImVec2                  SizeContents;                       // Size of contents (== extents reach of the drawing cursor) from previous frame
    ImVec2                  SizeContentsExplicit;               // Size of contents explicitly set by the user via SetNextWindowContentSize()
    ImRect                  ContentsRegionRect;                 // Maximum visible content position in window coordinates. ~~ (SizeContentsExplicit ? SizeContentsExplicit : Size - ScrollbarSizes) - CursorStartPos, per axis
    ImVec2                  WindowPadding;                      // Window padding at the time of begin. We need to lock it, in particular manipulation of the ShowBorder would have an effect
    ImGuiID                 MoveId;                             // == window->GetID("#MOVE")
    ImVec2                  Scroll;
    ImVec2                  ScrollTarget;                       // target scroll position. stored as cursor position with scrolling canceled out, so the highest point is always 0.0f. (FLT_MAX for no change)
    ImVec2                  ScrollTargetCenterRatio;            // 0.0f = scroll so that target position is at top, 0.5f = scroll so that target position is centered
    bool                    ScrollbarX, ScrollbarY;
    ImVec2                  ScrollbarSizes;
    float                   BorderSize;
    bool                    Active;                             // Set to true on Begin()
    bool                    WasActive;
    bool                    Accessed;                           // Set to true when any widget access the current window
    bool                    Collapsed;                          // Set when collapsing window to become only title-bar
    bool                    SkipItems;                          // == Visible && !Collapsed
    int                     BeginCount;                         // Number of Begin() during the current frame (generally 0 or 1, 1+ if appending via multiple Begin/End pairs)
    ImGuiID                 PopupId;                            // ID in the popup stack when this window is used as a popup/menu (because we use generic Name/ID for recycling)
    int                     AutoFitFramesX, AutoFitFramesY;
    bool                    AutoFitOnlyGrows;
    int                     AutoPosLastDirection;
    int                     HiddenFrames;
    int                     SetWindowPosAllowFlags;             // bit ImGuiSetCond_*** specify if SetWindowPos() call will succeed with this particular flag.
    int                     SetWindowSizeAllowFlags;            // bit ImGuiSetCond_*** specify if SetWindowSize() call will succeed with this particular flag.
    int                     SetWindowCollapsedAllowFlags;       // bit ImGuiSetCond_*** specify if SetWindowCollapsed() call will succeed with this particular flag.
    bool                    SetWindowPosCenterWanted;

    ImGuiDrawContext        DC;                                 // Temporary per-window data, reset at the beginning of the frame
    ImVector<ImGuiID>       IDStack;                            // ID stack. ID are hashes seeded with the value at the top of the stack
    ImRect                  ClipRect;                           // = DrawList->clip_rect_stack.back(). Scissoring / clipping rectangle. x1, y1, x2, y2.
    ImRect                  WindowRectClipped;                  // = WindowRect just after setup in Begin(). == window->Rect() for root window.
    int                     LastFrameActive;
    float                   ItemWidthDefault;
    ImGuiSimpleColumns      MenuColumns;                        // Simplified columns storage for menu items
    ImGuiStorage            StateStorage;
    float                   FontWindowScale;                    // Scale multiplier per-window
    ImDrawList*             DrawList;
    ImGuiWindow*            RootWindow;                         // If we are a child window, this is pointing to the first non-child parent window. Else point to ourself.
    ImGuiWindow*            RootNonPopupWindow;                 // If we are a child window, this is pointing to the first non-child non-popup parent window. Else point to ourself.
    ImGuiWindow*            ParentWindow;                       // If we are a child window, this is pointing to our parent window. Else point to NULL.

    // Navigation / Focus
    int                     FocusIdxAllCounter;                 // Start at -1 and increase as assigned via FocusItemRegister()
    int                     FocusIdxTabCounter;                 // (same, but only count widgets which you can Tab through)
    int                     FocusIdxAllRequestCurrent;          // Item being requested for focus
    int                     FocusIdxTabRequestCurrent;          // Tab-able item being requested for focus
    int                     FocusIdxAllRequestNext;             // Item being requested for focus, for next update (relies on layout to be stable between the frame pressing TAB and the next frame)
    int                     FocusIdxTabRequestNext;             // "

public:
    ImGuiWindow(const char* name);
    ~ImGuiWindow();

    ImGuiID     GetID(const char* str, const char* str_end = NULL);
    ImGuiID     GetID(const void* ptr);
    ImGuiID     GetIDNoKeepAlive(const char* str, const char* str_end = NULL);

    ImRect      Rect() const                            { return ImRect(Pos.x, Pos.y, Pos.x+Size.x, Pos.y+Size.y); }
    float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }
    float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }
    ImRect      TitleBarRect() const                    { return ImRect(Pos, ImVec2(Pos.x + SizeFull.x, Pos.y + TitleBarHeight())); }
    float       MenuBarHeight() const                   { return (Flags & ImGuiWindowFlags_MenuBar) ? CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f : 0.0f; }
    ImRect      MenuBarRect() const                     { float y1 = Pos.y + TitleBarHeight(); return ImRect(Pos.x, y1, Pos.x + SizeFull.x, y1 + MenuBarHeight()); }
};

* ImGuiIO

struct ImGuiIO
{
    // Settings (fill once)                 // Default value:
    ImVec2        DisplaySize;              // <unset>              // Display size, in pixels. For clamping windows positions.
    float         DeltaTime;                // = 1.0f/60.0f         // Time elapsed since last frame, in seconds.
    float         IniSavingRate;            // = 5.0f               // Maximum time between saving positions/sizes to .ini file, in seconds.
    const char*   IniFilename;              // = "imgui.ini"        // Path to .ini file. NULL to disable .ini saving.
    const char*   LogFilename;              // = "imgui_log.txt"    // Path to .log file (default parameter to ImGui::LogToFile when no file is specified).
    float         MouseDoubleClickTime;     // = 0.30f              // Time for a double-click, in seconds.
    float         MouseDoubleClickMaxDist;  // = 6.0f               // Distance threshold to stay in to validate a double-click, in pixels.
    float         MouseDragThreshold;       // = 6.0f               // Distance threshold before considering we are dragging
    int           KeyMap[ImGuiKey_COUNT];   // <unset>              // Map of indices into the KeysDown[512] entries array
    float         KeyRepeatDelay;           // = 0.250f             // When holding a key/button, time before it starts repeating, in seconds (for buttons in Repeat mode, etc.).
    float         KeyRepeatRate;            // = 0.020f             // When holding a key/button, rate at which it repeats, in seconds.
    void*         UserData;                 // = NULL               // Store your own data for retrieval by callbacks.
    ImFontAtlas*  Fonts;                    // <auto>               // Load and assemble one or more fonts into a single tightly packed texture. Output to Fonts array.
    float         FontGlobalScale;          // = 1.0f               // Global scale all fonts
    bool          FontAllowUserScaling;     // = false              // Allow user scaling text of individual window with CTRL+Wheel.
    ImFont*       FontDefault;              // = NULL               // Font to use on NewFrame(). Use NULL to uses Fonts->Fonts[0].
    ImVec2        DisplayFramebufferScale;  // = (1.0f,1.0f)        // For retina display or other situations where window coordinates are different from framebuffer coordinates. User storage only, presently not used by ImGui.
    ImVec2        DisplayVisibleMin;        // <unset> (0.0f,0.0f)  // If you use DisplaySize as a virtual space larger than your screen, set DisplayVisibleMin/Max to the visible area.
    ImVec2        DisplayVisibleMax;        // <unset> (0.0f,0.0f)  // If the values are the same, we defaults to Min=(0.0f) and Max=DisplaySize
    bool          OSXBehaviors;             // = defined(__APPLE__) // OS X style: Text editing cursor movement using Alt instead of Ctrl, Shortcuts using Cmd/Super instead of Ctrl, Line/Text Start and End using Cmd+Arrows instead of Home/End, Double click selects by word instead of selecting whole text, Multi-selection in lists uses Cmd/Super instead of Ctrl

    // User Functions
    // Rendering function, will be called in Render().
    // Alternatively you can keep this to NULL and call GetDrawData() after Render() to get the same pointer.
    // See example applications if you are unsure of how to implement this.
    void        (*RenderDrawListsFn)(ImDrawData* data);

    // Optional: access OS clipboard
    // (default to use native Win32 clipboard on Windows, otherwise uses a private clipboard. Override to access OS clipboard on other architectures)
    const char* (*GetClipboardTextFn)(void* user_data);
    void        (*SetClipboardTextFn)(void* user_data, const char* text);
    void*       ClipboardUserData;

    // Optional: override memory allocations. MemFreeFn() may be called with a NULL pointer.
    // (default to posix malloc/free)
    void*       (*MemAllocFn)(size_t sz);
    void        (*MemFreeFn)(void* ptr);

    // Optional: notify OS Input Method Editor of the screen position of your cursor for text input position (e.g. when using Japanese/Chinese IME in Windows)
    // (default to use native imm32 api on Windows)
    void        (*ImeSetInputScreenPosFn)(int x, int y);
    void*       ImeWindowHandle;            // (Windows) Set this to your HWND to get automatic IME cursor positioning.

    // Input - Fill before calling NewFrame()
    ImVec2      MousePos;                   // Mouse position, in pixels (set to -1,-1 if no mouse / on another screen, etc.)
    bool        MouseDown[5];               // Mouse buttons: left, right, middle + extras. ImGui itself mostly only uses left button (BeginPopupContext** are using right button). Others buttons allows us to track if the mouse is being used by your application + available to user as a convenience via IsMouse** API.
    float       MouseWheel;                 // Mouse wheel: 1 unit scrolls about 5 lines text.
    bool        MouseDrawCursor;            // Request ImGui to draw a mouse cursor for you (if you are on a platform without a mouse cursor).
    bool        KeyCtrl;                    // Keyboard modifier pressed: Control
    bool        KeyShift;                   // Keyboard modifier pressed: Shift
    bool        KeyAlt;                     // Keyboard modifier pressed: Alt
    bool        KeySuper;                   // Keyboard modifier pressed: Cmd/Super/Windows
    bool        KeysDown[512];              // Keyboard keys that are pressed (in whatever storage order you naturally have access to keyboard data)
    ImWchar     InputCharacters[16+1];      // List of characters input (translated by user from keypress+keyboard state). Fill using AddInputCharacter() helper.

    // Functions
    IMGUI_API void AddInputCharacter(ImWchar c);                        // Add new character into InputCharacters[]
    IMGUI_API void AddInputCharactersUTF8(const char* utf8_chars);      // Add new characters into InputCharacters[] from an UTF-8 string
    inline void    ClearInputCharacters() { InputCharacters[0] = 0; }   // Clear the text input buffer manually

    // Output - Retrieve after calling NewFrame()
    bool        WantCaptureMouse;           // Mouse is hovering a window or widget is active (= ImGui will use your mouse input). Use to hide mouse from the rest of your application
    bool        WantCaptureKeyboard;        // Widget is active (= ImGui will use your keyboard input). Use to hide keyboard from the rest of your application
    bool        WantTextInput;              // Some text input widget is active, which will read input characters from the InputCharacters array. Use to activate on screen keyboard if your system needs one
    float       Framerate;                  // Application framerate estimation, in frame per second. Solely for convenience. Rolling average estimation based on IO.DeltaTime over 120 frames
    int         MetricsAllocs;              // Number of active memory allocations
    int         MetricsRenderVertices;      // Vertices output during last call to Render()
    int         MetricsRenderIndices;       // Indices output during last call to Render() = number of triangles * 3
    int         MetricsActiveWindows;       // Number of visible root windows (exclude child windows)
    ImVec2      MouseDelta;                 // Mouse delta. Note that this is zero if either current or previous position are negative, so a disappearing/reappearing mouse won't have a huge delta for one frame.
};
* ImGui

ImGuiWindow* ImGui::GetParentWindow()
void ImGui::SetActiveID(ImGuiID id, ImGuiWindow* window)
void ImGui::ClearActiveID()
void ImGui::SetHoveredID(ImGuiID id)
void ImGui::KeepAliveID(ImGuiID id)
void ImGui::ItemSize(const ImVec2& size, float text_offset_y)
void ImGui::ItemSize(const ImRect& bb, float text_offset_y)
bool ImGui::ItemAdd(const ImRect& bb, const ImGuiID* id)
bool ImGui::IsClippedEx(const ImRect& bb, const ImGuiID* id, bool clip_even_when_logged)
bool ImGui::IsHovered(const ImRect& bb, ImGuiID id, bool flatten_childs)
bool ImGui::FocusableItemRegister(ImGuiWindow* window, bool is_active, bool tab_stop)
void ImGui::FocusableItemUnregister(ImGuiWindow* window)
ImVec2 ImGui::CalcItemSize(ImVec2 size, float default_x, float default_y)
float ImGui::CalcWrapWidthForPos(const ImVec2& pos, float wrap_pos_x)
void* ImGui::MemAlloc(size_t sz)
void ImGui::MemFree(void* ptr)
const char* ImGui::GetClipboardText()
void ImGui::SetClipboardText(const char* text)
const char* ImGui::GetVersion()
ImGuiContext* ImGui::GetCurrentContext()
void ImGui::SetCurrentContext(ImGuiContext* ctx)
ImGuiContext* ImGui::CreateContext(void* (*malloc_fn)(size_t), void (*free_fn)(void*))
void ImGui::DestroyContext(ImGuiContext* ctx)
ImGuiIO& ImGui::GetIO()
ImGuiStyle& ImGui::GetStyle()
ImDrawData* ImGui::GetDrawData()
float ImGui::GetTime()
int ImGui::GetFrameCount()
void ImGui::NewFrame()
void ImGui::Shutdown()
void ImGui::EndFrame()
void ImGui::Render()

void ImGui::PushClipRect(const ImVec2& clip_rect_min, const ImVec2& clip_rect_max, bool intersect_with_current_clip_rect)
void ImGui::PopClipRect()
const char* ImGui::FindRenderedTextEnd(const char* text, const char* text_end)

void ImGui::LogText(const char* fmt, ...)

void ImGui::RenderText(ImVec2 pos, const char* text, const char* text_end, bool hide_text_after_hash)
void ImGui::RenderTextClipped(const ImVec2& pos_min, const ImVec2& pos_max, const char* text, const char* text_end, const ImVec2* text_size_if_known, const ImVec2& align, const ImRect* clip_rect)
void ImGui::RenderFrame(ImVec2 p_min, ImVec2 p_max, ImU32 fill_col, bool border, float rounding)
void ImGui::RenderCollapseTriangle(ImVec2 p_min, bool is_open, float scale)
void ImGui::RenderBullet(ImVec2 pos)
void ImGui::RenderCheckMark(ImVec2 pos, ImU32 col)
ImVec2 ImGui::CalcTextSize(const char* text, const char* text_end, bool hide_text_after_double_hash, float wrap_width)
void ImGui::CalcListClipping(int items_count, float items_height, int* out_items_display_start, int* out_items_display_end)

bool ImGui::IsMouseHoveringRect(const ImVec2& r_min, const ImVec2& r_max, bool clip)
bool ImGui::IsMouseHoveringWindow()
bool ImGui::IsMouseHoveringAnyWindow()
int ImGui::GetKeyIndex(ImGuiKey imgui_key)
bool ImGui::IsKeyDown(int user_key_index)
bool ImGui::IsKeyPressed(int user_key_index, bool repeat)
bool ImGui::IsKeyReleased(int user_key_index)
bool ImGui::IsMouseDown(int button)
bool ImGui::IsMouseClicked(int button, bool repeat)
bool ImGui::IsMouseReleased(int button)
bool ImGui::IsMouseDoubleClicked(int button)
bool ImGui::IsMouseDragging(int button, float lock_threshold)
ImVec2 ImGui::GetMousePos()
ImVec2 ImGui::GetMousePosOnOpeningCurrentPopup()
ImVec2 ImGui::GetMouseDragDelta(int button, float lock_threshold)
void ImGui::ResetMouseDragDelta(int button)
ImGuiMouseCursor ImGui::GetMouseCursor()
void ImGui::SetMouseCursor(ImGuiMouseCursor cursor_type)
void ImGui::CaptureKeyboardFromApp(bool capture)
void ImGui::CaptureMouseFromApp(bool capture)
bool ImGui::IsItemHovered()
bool ImGui::IsItemHoveredRect()
bool ImGui::IsItemActive()
bool ImGui::IsItemClicked(int mouse_button)
bool ImGui::IsAnyItemHovered()
bool ImGui::IsAnyItemActive()
bool ImGui::IsItemVisible()
void ImGui::SetItemAllowOverlap()
ImVec2 ImGui::GetItemRectMin()
ImVec2 ImGui::GetItemRectMax()
ImVec2 ImGui::GetItemRectSize()
ImVec2 ImGui::CalcItemRectClosestPoint(const ImVec2& pos, bool on_edge, float outward)
void ImGui::SetTooltipV(const char* fmt, va_list args)
void ImGui::SetTooltip(const char* fmt, ...)
void ImGui::BeginTooltip()
void ImGui::EndTooltip()
void ImGui::OpenPopupEx(const char* str_id, bool reopen_existing)
void ImGui::OpenPopup(const char* str_id)
void ImGui::CloseCurrentPopup()
bool ImGui::BeginPopup(const char* str_id)
bool ImGui::BeginPopupModal(const char* name, bool* p_open, ImGuiWindowFlags extra_flags)
void ImGui::EndPopup()
bool ImGui::BeginPopupContextItem(const char* str_id, int mouse_button)
bool ImGui::BeginPopupContextWindow(bool also_over_items, const char* str_id, int mouse_button)
bool ImGui::BeginPopupContextVoid(const char* str_id, int mouse_button)
bool ImGui::BeginChild(const char* str_id, const ImVec2& size_arg, bool border, ImGuiWindowFlags extra_flags)
bool ImGui::BeginChild(ImGuiID id, const ImVec2& size_arg, bool border, ImGuiWindowFlags extra_flags)
void ImGui::EndChild()
bool ImGui::BeginChildFrame(ImGuiID id, const ImVec2& size, ImGuiWindowFlags extra_flags)
void ImGui::EndChildFrame()
ImGuiWindow* ImGui::FindWindowByName(const char* name)
bool ImGui::Begin(const char* name, bool* p_open, ImGuiWindowFlags flags)
bool ImGui::Begin(const char* name, bool* p_open, const ImVec2& size_on_first_use, float bg_alpha, ImGuiWindowFlags flags)
void ImGui::End()
void ImGui::FocusWindow(ImGuiWindow* window)
void ImGui::PushItemWidth(float item_width)
void ImGui::PopItemWidth()
float ImGui::CalcItemWidth()
void ImGui::PushFont(ImFont* font)
void  ImGui::PopFont()
void ImGui::PushAllowKeyboardFocus(bool allow_keyboard_focus)
void ImGui::PopAllowKeyboardFocus()
void ImGui::PushButtonRepeat(bool repeat)
void ImGui::PopButtonRepeat()
void ImGui::PushTextWrapPos(float wrap_pos_x)
void ImGui::PopTextWrapPos()
void ImGui::PushStyleColor(ImGuiCol idx, const ImVec4& col)
void ImGui::PopStyleColor(int count)
struct ImGuiStyleVarInfo
{
    ImGuiDataType   Type;
    ImU32           Offset;
    void*           GetVarPtr() const { return (void*)((unsigned char*)&GImGui->Style + Offset); }
};
void ImGui::PushStyleVar(ImGuiStyleVar idx, float val)
void ImGui::PushStyleVar(ImGuiStyleVar idx, const ImVec2& val)
void ImGui::PopStyleVar(int count)
const char* ImGui::GetStyleColName(ImGuiCol idx)
bool ImGui::IsWindowHovered()
bool ImGui::IsWindowFocused()
bool ImGui::IsRootWindowFocused()
bool ImGui::IsRootWindowOrAnyChildFocused()
bool ImGui::IsRootWindowOrAnyChildHovered()
float ImGui::GetWindowWidth()
float ImGui::GetWindowHeight()
ImVec2 ImGui::GetWindowPos()
void ImGui::SetWindowPos(const ImVec2& pos, ImGuiSetCond cond)
void ImGui::SetWindowPos(const char* name, const ImVec2& pos, ImGuiSetCond cond)
ImVec2 ImGui::GetWindowSize()
void ImGui::SetWindowSize(const ImVec2& size, ImGuiSetCond cond)
void ImGui::SetWindowSize(const char* name, const ImVec2& size, ImGuiSetCond cond)
void ImGui::SetWindowCollapsed(bool collapsed, ImGuiSetCond cond)
bool ImGui::IsWindowCollapsed()
void ImGui::SetWindowCollapsed(const char* name, bool collapsed, ImGuiSetCond cond)
void ImGui::SetWindowFocus()
void ImGui::SetWindowFocus(const char* name)
void ImGui::SetNextWindowPos(const ImVec2& pos, ImGuiSetCond cond)
void ImGui::SetNextWindowPosCenter(ImGuiSetCond cond)
void ImGui::SetNextWindowSize(const ImVec2& size, ImGuiSetCond cond)
void ImGui::SetNextWindowSizeConstraints(const ImVec2& size_min, const ImVec2& size_max, ImGuiSizeConstraintCallback custom_callback, void* custom_callback_user_data)
void ImGui::SetNextWindowContentSize(const ImVec2& size)
void ImGui::SetNextWindowContentWidth(float width)
void ImGui::SetNextWindowCollapsed(bool collapsed, ImGuiSetCond cond)
void ImGui::SetNextWindowFocus()
ImVec2 ImGui::GetContentRegionMax()
ImVec2 ImGui::GetContentRegionAvail()
float ImGui::GetContentRegionAvailWidth()
ImVec2 ImGui::GetWindowContentRegionMin()
ImVec2 ImGui::GetWindowContentRegionMax()
float ImGui::GetWindowContentRegionWidth()
float ImGui::GetTextLineHeight()
float ImGui::GetTextLineHeightWithSpacing()
float ImGui::GetItemsLineHeightWithSpacing()
ImDrawList* ImGui::GetWindowDrawList()
ImFont* ImGui::GetFont()
float ImGui::GetFontSize()
ImVec2 ImGui::GetFontTexUvWhitePixel()
void ImGui::SetWindowFontScale(float scale)
ImVec2 ImGui::GetCursorPos()
float ImGui::GetCursorPosX()
float ImGui::GetCursorPosY()
void ImGui::SetCursorPos(const ImVec2& local_pos)
void ImGui::SetCursorPosX(float x)
void ImGui::SetCursorPosY(float y)
ImVec2 ImGui::GetCursorStartPos()
ImVec2 ImGui::GetCursorScreenPos()
void ImGui::SetCursorScreenPos(const ImVec2& screen_pos)
float ImGui::GetScrollX()
float ImGui::GetScrollY()
float ImGui::GetScrollMaxX()
float ImGui::GetScrollMaxY()
void ImGui::SetScrollX(float scroll_x)
void ImGui::SetScrollY(float scroll_y)
void ImGui::SetScrollFromPosY(float pos_y, float center_y_ratio)
void ImGui::SetScrollHere(float center_y_ratio)
void ImGui::SetKeyboardFocusHere(int offset)
void ImGui::SetStateStorage(ImGuiStorage* tree)
ImGuiStorage* ImGui::GetStateStorage()
void ImGui::TextV(const char* fmt, va_list args)
void ImGui::Text(const char* fmt, ...)
void ImGui::TextColoredV(const ImVec4& col, const char* fmt, va_list args)
void ImGui::TextColored(const ImVec4& col, const char* fmt, ...)
void ImGui::TextDisabledV(const char* fmt, va_list args)
void ImGui::TextDisabled(const char* fmt, ...)
void ImGui::TextWrappedV(const char* fmt, va_list args)
void ImGui::TextWrapped(const char* fmt, ...)
void ImGui::TextUnformatted(const char* text, const char* text_end)
void ImGui::AlignFirstTextHeightToWidgets()
void ImGui::LabelTextV(const char* label, const char* fmt, va_list args)
void ImGui::LabelText(const char* label, const char* fmt, ...)
bool ImGui::ButtonBehavior(const ImRect& bb, ImGuiID id, bool* out_hovered, bool* out_held, ImGuiButtonFlags flags)
bool ImGui::ButtonEx(const char* label, const ImVec2& size_arg, ImGuiButtonFlags flags)
bool ImGui::Button(const char* label, const ImVec2& size_arg)
bool ImGui::SmallButton(const char* label)
bool ImGui::InvisibleButton(const char* str_id, const ImVec2& size_arg)
bool ImGui::CloseButton(ImGuiID id, const ImVec2& pos, float radius)
void ImGui::Image(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0, const ImVec2& uv1, const ImVec4& tint_col, const ImVec4& border_col)
bool ImGui::ImageButton(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0, const ImVec2& uv1, int frame_padding, const ImVec4& bg_col, const ImVec4& tint_col)
void ImGui::LogToTTY(int max_depth)
void ImGui::LogToFile(int max_depth, const char* filename)
void ImGui::LogToClipboard(int max_depth)
void ImGui::LogFinish()
void ImGui::LogButtons()
bool ImGui::TreeNodeBehaviorIsOpen(ImGuiID id, ImGuiTreeNodeFlags flags)
bool ImGui::TreeNodeBehavior(ImGuiID id, ImGuiTreeNodeFlags flags, const char* label, const char* label_end)
bool ImGui::CollapsingHeader(const char* label, ImGuiTreeNodeFlags flags)
bool ImGui::CollapsingHeader(const char* label, bool* p_open, ImGuiTreeNodeFlags flags)
bool ImGui::TreeNodeEx(const char* label, ImGuiTreeNodeFlags flags)
bool ImGui::TreeNodeExV(const char* str_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args)
bool ImGui::TreeNodeExV(const void* ptr_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args)
bool ImGui::TreeNodeV(const char* str_id, const char* fmt, va_list args)
bool ImGui::TreeNodeV(const void* ptr_id, const char* fmt, va_list args)
bool ImGui::TreeNodeEx(const char* str_id, ImGuiTreeNodeFlags flags, const char* fmt, ...)
bool ImGui::TreeNodeEx(const void* ptr_id, ImGuiTreeNodeFlags flags, const char* fmt, ...)
bool ImGui::TreeNode(const char* str_id, const char* fmt, ...)
bool ImGui::TreeNode(const void* ptr_id, const char* fmt, ...)
bool ImGui::TreeNode(const char* label)
void ImGui::TreeAdvanceToLabelPos()
float ImGui::GetTreeNodeToLabelSpacing()
void ImGui::SetNextTreeNodeOpen(bool is_open, ImGuiSetCond cond)
void ImGui::PushID(const char* str_id)
void ImGui::PushID(const char* str_id_begin, const char* str_id_end)
void ImGui::PushID(const void* ptr_id)
void ImGui::PushID(int int_id)
void ImGui::PopID()
ImGuiID ImGui::GetID(const char* str_id)
ImGuiID ImGui::GetID(const char* str_id_begin, const char* str_id_end)
ImGuiID ImGui::GetID(const void* ptr_id)
void ImGui::Bullet()
void ImGui::BulletTextV(const char* fmt, va_list args)
void ImGui::BulletText(const char* fmt, ...)
bool ImGui::InputScalarAsWidgetReplacement(const ImRect& aabb, const char* label, ImGuiDataType data_type, void* data_ptr, ImGuiID id, int decimal_precision)
int ImGui::ParseFormatPrecision(const char* fmt, int default_precision)
float ImGui::RoundScalar(float value, int decimal_precision)
bool ImGui::SliderBehavior(const ImRect& frame_bb, ImGuiID id, float* v, float v_min, float v_max, float power, int decimal_precision, ImGuiSliderFlags flags)
bool ImGui::SliderFloat(const char* label, float* v, float v_min, float v_max, const char* display_format, float power)
bool ImGui::VSliderFloat(const char* label, const ImVec2& size, float* v, float v_min, float v_max, const char* display_format, float power)
bool ImGui::SliderAngle(const char* label, float* v_rad, float v_degrees_min, float v_degrees_max)
bool ImGui::SliderInt(const char* label, int* v, int v_min, int v_max, const char* display_format)
bool ImGui::VSliderInt(const char* label, const ImVec2& size, int* v, int v_min, int v_max, const char* display_format)
bool ImGui::SliderFloatN(const char* label, float* v, int components, float v_min, float v_max, const char* display_format, float power)
bool ImGui::SliderFloat2(const char* label, float v[2], float v_min, float v_max, const char* display_format, float power)
bool ImGui::SliderFloat3(const char* label, float v[3], float v_min, float v_max, const char* display_format, float power)
bool ImGui::SliderFloat4(const char* label, float v[4], float v_min, float v_max, const char* display_format, float power)
bool ImGui::SliderIntN(const char* label, int* v, int components, int v_min, int v_max, const char* display_format)
bool ImGui::SliderInt2(const char* label, int v[2], int v_min, int v_max, const char* display_format)
bool ImGui::SliderInt3(const char* label, int v[3], int v_min, int v_max, const char* display_format)
bool ImGui::SliderInt4(const char* label, int v[4], int v_min, int v_max, const char* display_format)
bool ImGui::DragBehavior(const ImRect& frame_bb, ImGuiID id, float* v, float v_speed, float v_min, float v_max, int decimal_precision, float power)
bool ImGui::DragFloat(const char* label, float* v, float v_speed, float v_min, float v_max, const char* display_format, float power)
bool ImGui::DragFloatN(const char* label, float* v, int components, float v_speed, float v_min, float v_max, const char* display_format, float power)
bool ImGui::DragFloat2(const char* label, float v[2], float v_speed, float v_min, float v_max, const char* display_format, float power)
bool ImGui::DragFloat3(const char* label, float v[3], float v_speed, float v_min, float v_max, const char* display_format, float power)
bool ImGui::DragFloat4(const char* label, float v[4], float v_speed, float v_min, float v_max, const char* display_format, float power)
bool ImGui::DragFloatRange2(const char* label, float* v_current_min, float* v_current_max, float v_speed, float v_min, float v_max, const char* display_format, const char* display_format_max, float power)
bool ImGui::DragInt(const char* label, int* v, float v_speed, int v_min, int v_max, const char* display_format)
bool ImGui::DragIntN(const char* label, int* v, int components, float v_speed, int v_min, int v_max, const char* display_format)
bool ImGui::DragInt2(const char* label, int v[2], float v_speed, int v_min, int v_max, const char* display_format)
bool ImGui::DragInt3(const char* label, int v[3], float v_speed, int v_min, int v_max, const char* display_format)
bool ImGui::DragInt4(const char* label, int v[4], float v_speed, int v_min, int v_max, const char* display_format)
bool ImGui::DragIntRange2(const char* label, int* v_current_min, int* v_current_max, float v_speed, int v_min, int v_max, const char* display_format, const char* display_format_max)
void ImGui::PlotEx(ImGuiPlotType plot_type, const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size)
struct ImGuiPlotArrayGetterData
{
    const float* Values;
    int Stride;

    ImGuiPlotArrayGetterData(const float* values, int stride) { Values = values; Stride = stride; }
};
void ImGui::PlotLines(const char* label, const float* values, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size, int stride)
void ImGui::PlotLines(const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size)
void ImGui::PlotHistogram(const char* label, const float* values, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size, int stride)
void ImGui::PlotHistogram(const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size)
void ImGui::ProgressBar(float fraction, const ImVec2& size_arg, const char* overlay)
bool ImGui::Checkbox(const char* label, bool* v)
bool ImGui::CheckboxFlags(const char* label, unsigned int* flags, unsigned int flags_value)
bool ImGui::RadioButton(const char* label, bool active)
bool ImGui::RadioButton(const char* label, int* v, int v_button)
void ImGuiTextEditState::OnKeyPressed(int key)
void ImGuiTextEditCallbackData::DeleteChars(int pos, int bytes_count)
bool ImGui::InputTextEx(const char* label, char* buf, int buf_size, const ImVec2& size_arg, ImGuiInputTextFlags flags, ImGuiTextEditCallback callback, void* user_data)
bool ImGui::InputText(const char* label, char* buf, size_t buf_size, ImGuiInputTextFlags flags, ImGuiTextEditCallback callback, void* user_data)
bool ImGui::InputTextMultiline(const char* label, char* buf, size_t buf_size, const ImVec2& size, ImGuiInputTextFlags flags, ImGuiTextEditCallback callback, void* user_data)
bool ImGui::InputScalarEx(const char* label, ImGuiDataType data_type, void* data_ptr, void* step_ptr, void* step_fast_ptr, const char* scalar_format, ImGuiInputTextFlags extra_flags)
bool ImGui::InputFloat(const char* label, float* v, float step, float step_fast, int decimal_precision, ImGuiInputTextFlags extra_flags)
bool ImGui::InputInt(const char* label, int* v, int step, int step_fast, ImGuiInputTextFlags extra_flags)
bool ImGui::InputFloatN(const char* label, float* v, int components, int decimal_precision, ImGuiInputTextFlags extra_flags)
bool ImGui::InputFloat2(const char* label, float v[2], int decimal_precision, ImGuiInputTextFlags extra_flags)
bool ImGui::InputFloat3(const char* label, float v[3], int decimal_precision, ImGuiInputTextFlags extra_flags)
bool ImGui::InputFloat4(const char* label, float v[4], int decimal_precision, ImGuiInputTextFlags extra_flags)
bool ImGui::InputIntN(const char* label, int* v, int components, ImGuiInputTextFlags extra_flags)
bool ImGui::InputInt2(const char* label, int v[2], ImGuiInputTextFlags extra_flags)
bool ImGui::InputInt3(const char* label, int v[3], ImGuiInputTextFlags extra_flags)
bool ImGui::InputInt4(const char* label, int v[4], ImGuiInputTextFlags extra_flags)
bool ImGui::Combo(const char* label, int* current_item, const char* const* items, int items_count, int height_in_items)
bool ImGui::Combo(const char* label, int* current_item, const char* items_separated_by_zeros, int height_in_items)
bool ImGui::Combo(const char* label, int* current_item, bool (*items_getter)(void*, int, const char**), void* data, int items_count, int height_in_items)
bool ImGui::Selectable(const char* label, bool selected, ImGuiSelectableFlags flags, const ImVec2& size_arg)
bool ImGui::Selectable(const char* label, bool* p_selected, ImGuiSelectableFlags flags, const ImVec2& size_arg)
bool ImGui::ListBoxHeader(const char* label, const ImVec2& size_arg)
bool ImGui::ListBoxHeader(const char* label, int items_count, int height_in_items)
void ImGui::ListBoxFooter()
bool ImGui::ListBox(const char* label, int* current_item, const char* const* items, int items_count, int height_items)
bool ImGui::ListBox(const char* label, int* current_item, bool (*items_getter)(void*, int, const char**), void* data, int items_count, int height_in_items)
bool ImGui::MenuItem(const char* label, const char* shortcut, bool selected, bool enabled)
bool ImGui::MenuItem(const char* label, const char* shortcut, bool* p_selected, bool enabled)
bool ImGui::BeginMainMenuBar()
void ImGui::EndMainMenuBar()
bool ImGui::BeginMenuBar()
void ImGui::EndMenuBar()
bool ImGui::BeginMenu(const char* label, bool enabled)
void ImGui::EndMenu()
bool ImGui::ColorButton(const ImVec4& col, bool small_height, bool outline_border)
bool ImGui::ColorEdit3(const char* label, float col[3])
bool ImGui::ColorEdit4(const char* label, float col[4], bool alpha)
void ImGui::ColorEditMode(ImGuiColorEditMode mode)
void ImGui::Separator()
void ImGui::Spacing()
void ImGui::Dummy(const ImVec2& size)
bool ImGui::IsRectVisible(const ImVec2& size)
bool ImGui::IsRectVisible(const ImVec2& rect_min, const ImVec2& rect_max)
void ImGui::BeginGroup()
void ImGui::EndGroup()
void ImGui::SameLine(float pos_x, float spacing_w)
void ImGui::NewLine()
void ImGui::NextColumn()
int ImGui::GetColumnIndex()
int ImGui::GetColumnsCount()
float ImGui::GetColumnOffset(int column_index)
void ImGui::SetColumnOffset(int column_index, float offset)
float ImGui::GetColumnWidth(int column_index)
void ImGui::Columns(int columns_count, const char* id, bool border)
void ImGui::Indent(float indent_w)
void ImGui::Unindent(float indent_w)
void ImGui::TreePush(const char* str_id)
void ImGui::TreePush(const void* ptr_id)
void ImGui::TreePushRawID(ImGuiID id)
void ImGui::TreePop()
void ImGui::Value(const char* prefix, bool b)
void ImGui::Value(const char* prefix, int v)
void ImGui::Value(const char* prefix, unsigned int v)
void ImGui::Value(const char* prefix, float v, const char* float_format)
void ImGui::ValueColor(const char* prefix, const ImVec4& v)
void ImGui::ValueColor(const char* prefix, ImU32 v)
void ImGui::ShowMetricsWindow(bool* p_open)
